package com.quick.disarm;

import android.annotation.SuppressLint;
import android.bluetooth.BluetoothGatt;
import android.bluetooth.BluetoothGattCharacteristic;
import android.bluetooth.BluetoothGattService;
import android.os.Build;
import android.text.TextUtils;
import android.util.Log;

import com.quick.disarm.infra.Utils;

import java.nio.ByteBuffer;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Locale;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

public class StarlinkCommandDispatcher {
    private static final String TAG = StarlinkCommandDispatcher.class.getSimpleName();

    public static final byte COMMAND_UNLOCK = 1;

    //  It seems that we can't generate the device UUID used by the original ituran app ourselves since
    //  Settings.Secure.getString(paramContext.getContentResolver(), "android_id") generates different values
    //  per app signing key and user. (see https://developer.android.com/reference/android/provider/Settings.Secure#ANDROID_ID)
    //  Our only option is to hardcode the value that is generated by the original app.
    // PENDING: This may be resolved by going through the activation
    //  process using our own generated device uuid
    private static final String PIXEL_7_UUID_GENERATED_BY_ORIGINAL_APP = "f18e7f1218d7dd82";
    private static final String PIXEL_9_UUID_GENERATED_BY_ORIGINAL_APP = "ac2277bd0e024ec7";

    private BluetoothGatt mGatt;
    private BluetoothGattCharacteristic mSendCharacteristic;
    private BluetoothGattCharacteristic mRandomCharacteristic;
    private String mDeviceUuid;
    private byte[] mRandom;

    private Car mConnectedCar;

    private StarlinkCommandDispatcher() {
        // Prevent instances
    }

    private static final class InstanceHolder {
        private static final StarlinkCommandDispatcher INSTANCE = new StarlinkCommandDispatcher();
    }

    public static StarlinkCommandDispatcher get() {
        return InstanceHolder.INSTANCE;
    }

    public void init(BluetoothGatt gatt, Car connectedCar) {
        mGatt = gatt;
        mConnectedCar = connectedCar;
        mDeviceUuid = Utils.getDeviceUuid(QuickDisarmApplication.getAppContext());

        initCharacteristics();

        Log.d(TAG, "Initialized with device UUID = " + mDeviceUuid + " and car =" + mConnectedCar);
    }

    private void initCharacteristics() {
        final BluetoothGattService bluetoothGattService = mGatt.getService(StartLinkGattCallback.SERVICE_UUID);
        if (bluetoothGattService != null) {
            mSendCharacteristic = bluetoothGattService.getCharacteristic(StartLinkGattCallback.SEND_COMMAND_UUID);
            mRandomCharacteristic = bluetoothGattService.getCharacteristic(StartLinkGattCallback.RANDOM_NUMBER_UUID);
        } else {
            Log.e(TAG, "Failed to get service from Gatt server: " + StartLinkGattCallback.SERVICE_UUID);
        }
    }

    @SuppressLint("MissingPermission")
    public void dispatchReadRandomCommand() {
        if (mRandomCharacteristic == null) {
            initCharacteristics();
        }
        if (mRandomCharacteristic != null) {
            if (mGatt.readCharacteristic(mRandomCharacteristic)) {
                Log.d(TAG, "Started reading device random...");
            } else {
                Log.e(TAG, "Failed to read device random - readCharacteristic returned false");
            }
        } else {
            Log.e(TAG, "Failed to read random - characteristics not initialized");
        }
    }

    public void setRandom(byte[] random) {
        if (!Arrays.equals(mRandom, random)) {
            Log.d(TAG, "Updated random from " + bytesToHex(mRandom) + " to " + bytesToHex(random));
            mRandom = random;
        }
    }

    public void dispatchDisarmCommand() {
        dispatchWritePacketCommand(COMMAND_UNLOCK);
    }

    @SuppressLint("MissingPermission")
    private void dispatchWritePacketCommand(byte commandByte) {
        final byte[] commandBufferBytes = new byte[12];
        commandBufferBytes[0] = 1;
        commandBufferBytes[1] = commandByte;

        int codeAsUnsignedInt;
        hexToBytes(mDeviceUuid, commandBufferBytes, 2);
        if (commandByte == COMMAND_UNLOCK) {
            codeAsUnsignedInt = Short.toUnsignedInt(Short.parseShort(mConnectedCar.getIturanCode()));
        } else {
            codeAsUnsignedInt = 0;
        }
        commandBufferBytes[10] = (byte) (codeAsUnsignedInt & 0xFF);
        commandBufferBytes[11] = (byte) ((codeAsUnsignedInt & 0xFF00) >> 8);
        if (BuildConfig.DEBUG) {
            Log.d(TAG, "Command buffer: " + bytesToHex(commandBufferBytes));
        }

        final byte[] randomizedSerialBytes = keyGen(mConnectedCar.getStarlinkSerial(), mRandom);
        if (BuildConfig.DEBUG) {
            Log.d(TAG, "Key: " + bytesToHex(randomizedSerialBytes));
        }

        final byte[] encryptedRandomizedSerialBytes = encryptCommand(commandBufferBytes, randomizedSerialBytes);
        if (BuildConfig.DEBUG) {
            Log.d(TAG, "Encrypted command: " + bytesToHex(encryptedRandomizedSerialBytes));
        }

        if (Build.VERSION.SDK_INT >= 33) {
            mGatt.writeCharacteristic(mSendCharacteristic, encryptedRandomizedSerialBytes, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT);
        } else {
            mSendCharacteristic.setValue(encryptedRandomizedSerialBytes);
            mGatt.writeCharacteristic(mSendCharacteristic);
        }
    }

    private static String bytesToHex(byte[] paramArrayOfbyte) {
        final StringBuilder stringBuilder = new StringBuilder("[");
        if (paramArrayOfbyte != null) {
            for (byte b1 : paramArrayOfbyte) {
                stringBuilder.append(String.format(Locale.ENGLISH, " %02x", Byte.toUnsignedInt(b1)));
            }
        }
        stringBuilder.append(" ]");
        return stringBuilder.toString();
    }

    private static byte[] encryptCommand(byte[] paramArrayOfbyte1, byte[] paramArrayOfbyte2) {
        try {
            final Cipher cipher = Cipher.getInstance("AES");
            SecretKeySpec secretKeySpec = new SecretKeySpec(paramArrayOfbyte2, "AES");
            cipher.init(1, secretKeySpec);
            paramArrayOfbyte1 = cipher.doFinal(paramArrayOfbyte1);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |
                 BadPaddingException | IllegalBlockSizeException noSuchAlgorithmException1) {
            noSuchAlgorithmException1.printStackTrace();
        }
        return paramArrayOfbyte1;
    }

    private static void hexToBytes(String hex, byte[] targetByteArray, int offset) {
        if (TextUtils.isEmpty(hex) || hex.length() % 2 != 0) {
            throw new NumberFormatException("Not a hex string: " + hex);
        }

        if (targetByteArray.length - offset < hex.length() / 2) {
            throw new ArrayIndexOutOfBoundsException("Not enough room in buffer");
        }

        for (int i = 0, j; i < hex.length(); i = j) {
            int k = i / 2;
            j = i + 2;
            targetByteArray[k + offset] = (byte) Short.parseShort(hex.substring(i, j), 16);
        }
    }

    private static byte[] keyGen(int deviceSerial, byte[] random) {
        random = random.clone();
        if (random.length != 16) {
            Log.e(TAG, "random size must be equal to 16 - got " + random.length);
            return null;
        }

        final byte[] serialByteArray = ByteBuffer.allocate(4).putInt(deviceSerial).array();
        for (int i = 0; i < random.length; i++) {
            random[i] = (byte) (random[i] ^ serialByteArray[i % serialByteArray.length]);
        }
        return random;
    }
}
