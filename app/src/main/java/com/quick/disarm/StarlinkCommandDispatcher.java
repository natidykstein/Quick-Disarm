package com.quick.disarm;

import android.annotation.SuppressLint;
import android.bluetooth.BluetoothGatt;
import android.bluetooth.BluetoothGattCharacteristic;
import android.bluetooth.BluetoothGattService;
import android.content.Context;
import android.os.Build;
import android.text.TextUtils;
import android.util.Log;

import java.nio.ByteBuffer;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Locale;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

public class StarlinkCommandDispatcher {
    private static final String TAG = StarlinkCommandDispatcher.class.getSimpleName();

    public static final byte COMMAND_UNLOCK = 1;

    //  It seems that we can't generate the device UUID used by the original ituran app ourselves since
    //  Settings.Secure.getString(paramContext.getContentResolver(), "android_id") generates different values
    //  per app signing key and user. (see https://developer.android.com/reference/android/provider/Settings.Secure#ANDROID_ID)
    //  Our only option is to hardcode the values that are generated by the original app here.
    // PENDING: This may be resolved by going through the activation process using
    //  our own generated device uuid - but I'm not sure it worth the effort.
    //  (maybe only if the original app will stop logging it :))
    private static final String PIXEL_7_UUID_GENERATED_BY_ORIGINAL_APP = "f18e7f1218d7dd82";
    private static final String PIXEL_9_UUID_GENERATED_BY_ORIGINAL_APP = "ac2277bd0e024ec7";

    private BluetoothGatt mGatt;
    private BluetoothGattCharacteristic mSendCharacteristic;
    private BluetoothGattCharacteristic mRandomCharacteristic;
    private String mDeviceUuid = PIXEL_9_UUID_GENERATED_BY_ORIGINAL_APP;
    private byte[] mRandom;

    private Car mConnectedCar;

    private StarlinkCommandDispatcher() {
        // Prevent instances
    }

    private static final class InstanceHolder {
        private static final StarlinkCommandDispatcher INSTANCE = new StarlinkCommandDispatcher();
    }

    public static StarlinkCommandDispatcher get() {
        return InstanceHolder.INSTANCE;
    }

    public void init(BluetoothGatt gatt, Car connectedCar) {
        mGatt = gatt;
        mConnectedCar = connectedCar;

        initCharacteristics();

        Log.d(TAG, "Initialized with device UUID = " + mDeviceUuid + " and car =" + mConnectedCar);
    }

    private void initCharacteristics() {
        final BluetoothGattService bluetoothGattService = mGatt.getService(StartLinkGattCallback.SERVICE_UUID);
        if (bluetoothGattService != null) {
            mSendCharacteristic = bluetoothGattService.getCharacteristic(StartLinkGattCallback.SEND_COMMAND_UUID);
            mRandomCharacteristic = bluetoothGattService.getCharacteristic(StartLinkGattCallback.RANDOM_NUMBER_UUID);
        } else {
            Log.e(TAG, "Failed to get service from Gatt server: " + StartLinkGattCallback.SERVICE_UUID);
        }
    }

    @SuppressLint("MissingPermission")
    public void dispatchReadRandomCommand() {
        if (mRandomCharacteristic == null) {
            initCharacteristics();
        }
        if (mRandomCharacteristic != null) {
            if (mGatt.readCharacteristic(mRandomCharacteristic)) {
                Log.d(TAG, "Started reading device random...");
            } else {
                Log.e(TAG, "Failed to read device random - readCharacteristic returned false");
            }
        } else {
            Log.e(TAG, "Failed to read random - characteristics not initialized");
        }
    }

    public void setRandom(byte[] random) {
        Log.d(TAG, "Updated random from " + bytesToHex(mRandom) + " to " + bytesToHex(random));
        mRandom = random;
    }

    public void dispatchDisarmCommand() {
        dispatchWritePacketCommand(COMMAND_UNLOCK);
    }

    @SuppressLint("MissingPermission")
    private void dispatchWritePacketCommand(byte commandByte) {
        final byte[] commandBufferBytes = new byte[12];
        commandBufferBytes[0] = 1;
        commandBufferBytes[1] = commandByte;

        int codeAsUnsignedInt;
        hexToBytes(mDeviceUuid, commandBufferBytes, 2);
        if (commandByte == COMMAND_UNLOCK) {
            codeAsUnsignedInt = Short.toUnsignedInt(Short.parseShort(mConnectedCar.getIturanCode()));
        } else {
            codeAsUnsignedInt = 0;
        }
        commandBufferBytes[10] = (byte) (codeAsUnsignedInt & 0xFF);
        commandBufferBytes[11] = (byte) ((codeAsUnsignedInt & 0xFF00) >> 8);
        Log.d(TAG, "Command buffer: " + bytesToHex(commandBufferBytes));

        final byte[] randomizedSerialBytes = keyGen(mConnectedCar.getStarlinkSerial(), mRandom);
        Log.d(TAG, "Key: " + bytesToHex(randomizedSerialBytes));

        final byte[] encryptedRandomizedSerialBytes = encryptCommand(commandBufferBytes, randomizedSerialBytes);
        Log.d(TAG, "Encrypted command: " + bytesToHex(encryptedRandomizedSerialBytes));

        if (Build.VERSION.SDK_INT >= 33) {
            mGatt.writeCharacteristic(mSendCharacteristic, encryptedRandomizedSerialBytes, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT);
        } else {
            mSendCharacteristic.setValue(encryptedRandomizedSerialBytes);
            mGatt.writeCharacteristic(mSendCharacteristic);
        }
    }

    private static String bytesToHex(byte[] paramArrayOfbyte) {
        StringBuilder stringBuilder = new StringBuilder("[");
        if (paramArrayOfbyte != null) {
            int i = paramArrayOfbyte.length;
            for (byte b = 0; b < i; b++) {
                byte b1 = paramArrayOfbyte[b];
                stringBuilder.append(String.format(Locale.ENGLISH, " %02x", new Object[]{Integer.valueOf(Byte.toUnsignedInt(b1))}));
            }
        }
        stringBuilder.append(" ]");
        return stringBuilder.toString();
    }

    private static byte[] encryptCommand(byte[] paramArrayOfbyte1, byte[] paramArrayOfbyte2) {
        try {
            Cipher cipher = Cipher.getInstance("AES");
            SecretKeySpec secretKeySpec = new SecretKeySpec(paramArrayOfbyte2, "AES");
            cipher.init(1, secretKeySpec);
            paramArrayOfbyte1 = cipher.doFinal(paramArrayOfbyte1);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |
                 BadPaddingException | IllegalBlockSizeException noSuchAlgorithmException1) {
            noSuchAlgorithmException1.printStackTrace();
        }
        return paramArrayOfbyte1;
    }

    private static void hexToBytes(String hex, byte[] targetByteArray, int paramInt) {
        if (!TextUtils.isEmpty(hex) && hex.length() % 2 == 0) {
            if (targetByteArray.length - paramInt >= hex.length() / 2) {
                for (int i = 0, j; i < hex.length(); i = j) {
                    int k = i / 2;
                    j = i + 2;
                    targetByteArray[k + paramInt] = (byte) Short.parseShort(hex.substring(i, j), 16);
                }
                return;
            }
            throw new ArrayIndexOutOfBoundsException("Not enough room in buffer");
        }
        throw new NumberFormatException("Not a hex string!");
    }

    private static byte[] keyGen(int deviceSerial, byte[] random) {
        if (random == null) {
            return null;
        }
        random = random.clone();
        if (random.length != 16) {
            return null;
        }

        try {
            final byte[] serialByteArray = ByteBuffer.allocate(4).putInt(deviceSerial).array();
            Log.d("BleUtils", "keyGen: serialBytes = " + bytesToHex(serialByteArray));
            for (byte b = 0; b < random.length; b++) {
                random[b] = (byte) (random[b] ^ serialByteArray[b % serialByteArray.length]);
            }
            return random;
        } catch (NumberFormatException numberFormatException) {
            return null;
        }
    }
}
